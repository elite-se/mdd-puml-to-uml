modeltype UML uses "http://www.eclipse.org/uml2/5.0.0/UML";
modeltype PlantUML uses "http://www.mdd.elite/plantuml/PlantUML";

modeltype ECore uses "http://www.eclipse.org/emf/2002/Ecore";

transformation PlantUMLToUMLTransformation(in source: PlantUML, out target: UML);

main() {
	var paramCounter := 0;
	object UML::Model {
		var diagrams = source.rootObjects()[Diagram];
		
		packagedElement += object UML::Package {
			name := 'Static';
			packagedElement += diagrams.elements[ParticipantDefinition].participant -> map toClass();
		};
		
		packagedElement += diagrams -> map toCollaboration();
			
		name := diagrams -> iterate( i: Diagram; newName : String = '' | newName + i.getName());
	};
}

query Diagram::getName(): String {
	if (self.elements[TitleDefinition]->isEmpty()) then {
		return 'Unnamed Model';
	} endif;
	return self.elements[TitleDefinition] -> iterate ( t: TitleDefinition; title : String = '' |
		title
		+ (if title = '' then '' else ' ' endif)
		+ t.getTitle()
	);
}

query TitleDefinition::getTitle(): String {
	return self.titleParts -> iterate ( tp: String; title: String = '' |
		title 
		+ (if title = '' then '' else ' ' endif)
		+ tp
	);
}

mapping Participant::toClass(): UML::Class {
	name := 
		if (self.type.oclIsUndefined())
		then self.name.firstToUpper()
		else self.type
		endif;
}

mapping Diagram::toCollaboration(): UML::Collaboration {
	name := self.getName();
	var interaction = object UML::Interaction {
		name := self.getName();
	};
	classifierBehavior := interaction;
	ownedBehavior := interaction;
	interaction.lifeline := self.elements[ParticipantDefinition].participant -> map toLifeline(interaction);
	interaction.message += self.elements[MessageDefinition] -> map toUMLMessage(interaction);
}

mapping ReplyMessageDefinition::test(out message : UML::Message, out sendOccurence : UML::MessageOccurrenceSpecification) {
	message.name := self.message.name;
	sendOccurence.message := message;
}

mapping Participant::toLifeline(parentInteraction: UML::Interaction): Lifeline {
	if (self.name.oclIsUndefined()) then {
		// anonymous Participant
		name := ':' + self.type;
	} else {
		name := self.name;
	} endif;
	interaction := parentInteraction;
	var representedProperty := object UML::Property {
		name := result.name.toLower();
		type := self.resolveone(UML::Class);
	};
	represents := representedProperty;
	var parentCollaboration = parentInteraction.context.oclAsType(UML::Collaboration); 
	parentCollaboration.collaborationRole += representedProperty;
	parentCollaboration.ownedAttribute += representedProperty;
}

mapping MessageDefinition::toUMLMessage(inout parentInteraction : UML::Interaction) : UML::Message disjuncts 
RequestMessageDefinition::toUMLMessage,
ReplyMessageDefinition::toUMLMessage { }

mapping MessageDefinition::senderAndReceiver(inout parentInteraction : UML::Interaction): UML::Message {
	interaction := parentInteraction;
	var sendOccurence := object MessageOccurrenceSpecification {name := result.name + '_' + 'send'; 
		message := result;
		covered := self.sender.resolveone(UML::Lifeline);
		enclosingInteraction := parentInteraction;
	};
	var receiveOccurence := object MessageOccurrenceSpecification {
		message := result;
		covered := self.receiver.resolveone(UML::Lifeline);
		enclosingInteraction := parentInteraction;
	};
	sendEvent := sendOccurence;
	receiveEvent := receiveOccurence;
	parentInteraction.fragment += sendOccurence;
	parentInteraction.fragment += receiveOccurence;
}

property messageOccurenceSpecificationCounter : Integer = 0;

mapping RequestMessageDefinition::toUMLMessage(inout parentInteraction : UML::Interaction): UML::Message inherits
MessageDefinition::senderAndReceiver {
	name := self.message.name;
	sendEvent.name := name + '_' + 'send' + messageOccurenceSpecificationCounter.toString();
	receiveEvent.name := name + '_' + 'receive' + messageOccurenceSpecificationCounter.toString();
	messageOccurenceSpecificationCounter := messageOccurenceSpecificationCounter + 1;
	messageSort := 
		if (self.arrow = RequestArrow::RIGHT_SYNC or self.arrow = RequestArrow::LEFT_SYNC)
		then MessageSort::synchCall
		else MessageSort::asynchCall
		endif;
	argument += self.message.arguments.toArgument();
	var receiverClass : UML::Class = self.receiver.resolveone(UML::Lifeline).represents.type.oclAsType(UML::Class);
	if (not receiverClass.ownedOperation.name->includes(self.message.name)) receiverClass.ownedOperation += self.message -> map toOperation();	
}

mapping PlantUML::RequestMessage::toOperation(): UML::Operation {
	name := self.name;
	ownedParameter += self.arguments -> map toParameter();
}

property inParamCounter : Integer = 0;

mapping RequestMessageArgument::toParameter(): UML::Parameter {
	if (self.name.oclIsUndefined()) {
		name := 'inParam' + inParamCounter.toString();
		inParamCounter := inParamCounter + 1;
	} else {
		name := self.name;
	} endif;
}

query RequestMessageArgument::toArgument(): UML::LiteralSpecification {
	var res := self.value.map toLiteralSpecification();
	res.name := self.name;
	return res;
}

mapping PlantUML::Value::toLiteralSpecification(): UML::LiteralSpecification disjuncts 
PlantUML::LiteralBoolean::toLiteralSpecification,
PlantUML::LiteralInteger::toLiteralSpecification, 
PlantUML::LiteralNull::toLiteralSpecification,
PlantUML::LiteralString::toLiteralSpecification,
PlantUML::LiteralReal::toLiteralSpecification,
PlantUML::LiteralUnlimitedNatural::toLiteralSpecification
{ }

mapping PlantUML::LiteralBoolean::toLiteralSpecification(): UML::LiteralBoolean {
	value := self.value;
}

mapping PlantUML::LiteralInteger::toLiteralSpecification(): UML::LiteralInteger {
	value := self.value
}

mapping PlantUML::LiteralNull::toLiteralSpecification(): UML::LiteralNull { }

mapping PlantUML::LiteralString::toLiteralSpecification(): UML::LiteralString {
	value := self.value;
}

mapping PlantUML::LiteralReal::toLiteralSpecification(): UML::LiteralReal {
	value := self.value;
}

mapping PlantUML::LiteralUnlimitedNatural::toLiteralSpecification(): UML::LiteralUnlimitedNatural {
	// TODO: Check
	value := -1;
}

property returnParamCounter : Integer = 0;

mapping ReplyMessageDefinition::toUMLMessage(inout parentInteraction : UML::Interaction): UML::Message inherits
MessageDefinition::senderAndReceiver {
	name := self.message.name;
	sendEvent.name := name + '_' + 'send' + messageOccurenceSpecificationCounter.toString();
	receiveEvent.name := name + '_' + 'receive' + messageOccurenceSpecificationCounter.toString();
	messageOccurenceSpecificationCounter := messageOccurenceSpecificationCounter + 1;
	messageSort := MessageSort::reply;
	var operation : UML::Operation := self.getOperation(result.name);
	if (not operation.oclIsUndefined()) {
		operation.ownedParameter += self.message.arguments -> map toParameter();
		if (not self.message.value.oclIsUndefined()) then {
			operation.ownedParameter += object UML::Parameter { 
				name := 'returnParam' + returnParamCounter.toString();
				returnParamCounter := returnParamCounter + 1;
				direction := ParameterDirectionKind::_return;
			}
		} endif;
	}
}

query ReplyMessageDefinition::getOperation(name : String): UML::Operation {
	return self.getClass().ownedOperation->any(op : UML::Operation | op.name = name);
}

query ReplyMessageDefinition::getClass(): UML::Class {
	return self.sender.resolveone(UML::Lifeline).represents.type.oclAsType(UML::Class);
}

property outParamCounter : Integer = 0;

mapping ReplyMessageArgument::toParameter(): UML::Parameter {
	name := 'outParam' + outParamCounter.toString();
	outParamCounter := outParamCounter + 1;
	direction := ParameterDirectionKind::_out;
}

