modeltype UML uses "http://www.eclipse.org/uml2/5.0.0/UML";
modeltype PlantUML uses "http://www.mdd.elite/plantuml/PlantUML";

modeltype ECore uses "http://www.eclipse.org/emf/2002/Ecore";

transformation PlantUMLToUMLTransformation(in source: PlantUML, out target: UML);

main() {
	object UML::Model {
		var diagrams = source.rootObjects()[Diagram];
		
		packagedElement += object UML::Package {
			name := 'Static';
			packagedElement += diagrams.elements[ParticipantDefinition].participant -> map toClass();
		};
		
		packagedElement += diagrams -> map toCollaboration();
			
		name := diagrams -> iterate( i: Diagram; newName : String = '' | newName + i.getName());
	};
}

query Diagram::getName(): String {
	if (self.elements[TitleDefinition]->isEmpty()) then {
		return 'Unnamed Model';
	} endif;
	return self.elements[TitleDefinition] -> iterate ( t: TitleDefinition; title : String = '' |
		title
		+ (if title = '' then '' else ' ' endif)
		+ t.getTitle()
	);
}

query TitleDefinition::getTitle(): String {
	return self.titleParts -> iterate ( tp: String; title: String = '' |
		title 
		+ (if title = '' then '' else ' ' endif)
		+ tp
	);
}

mapping Participant::toClass(): UML::Class {
	name := 
		if (self.type.oclIsUndefined())
		then self.name.firstToUpper()
		else self.type
		endif;
}

mapping Diagram::toCollaboration(): UML::Collaboration {
	name := self.getName();
	var interaction = object UML::Interaction {
		name := self.getName();
	};
	classifierBehavior := interaction;
	ownedBehavior := interaction;
	interaction.lifeline := self.elements[ParticipantDefinition].participant -> map toLifeline(interaction);
	interaction.message += self.elements[MessageDefinition] -> map toUMLMessage(interaction);
}

mapping ReplyMessageDefinition::test(out message : UML::Message, out sendOccurence : UML::MessageOccurrenceSpecification) {
	message.name := self.message.name;
	sendOccurence.message := message;
}

mapping Participant::toLifeline(parentInteraction: UML::Interaction): Lifeline {
	if (self.name.oclIsUndefined()) then {
		// anonymous Participant
		name := ':' + self.type;
	} else {
		name := self.name;
	} endif;
	interaction := parentInteraction;
	var representedProperty := object UML::Property {
		name := result.name.toLower();
		type := self.resolveone(UML::Class);
	};
	represents := representedProperty;
	var parentCollaboration = parentInteraction.context.oclAsType(UML::Collaboration); 
	parentCollaboration.collaborationRole += representedProperty;
	parentCollaboration.ownedAttribute += representedProperty;
}

mapping MessageDefinition::toUMLMessage(inout parentInteraction : UML::Interaction) : UML::Message disjuncts 
RequestMessageDefinition::toUMLMessage,
ReplyMessageDefinition::toUMLMessage { }

mapping MessageDefinition::senderAndReceiver(inout parentInteraction : UML::Interaction): UML::Message {
	interaction := parentInteraction;
	var sendOccurence := object MessageOccurrenceSpecification {name := result.name + '_' + 'send'; 
		message := result;
		covered := self.sender.resolveone(UML::Lifeline);
		enclosingInteraction := parentInteraction;
	};
	var receiveOccurence := object MessageOccurrenceSpecification {
		message := result;
		covered := self.receiver.resolveone(UML::Lifeline);
		enclosingInteraction := parentInteraction;
	};
	sendEvent := sendOccurence;
	receiveEvent := receiveOccurence;
	parentInteraction.fragment += sendOccurence;
	parentInteraction.fragment += receiveOccurence;
}

mapping RequestMessageDefinition::toUMLMessage(inout parentInteraction : UML::Interaction): UML::Message inherits
MessageDefinition::senderAndReceiver {
	name := self.message.name;
	sendEvent.name := name + '_' + 'send';
	receiveEvent.name := name + '_' + 'receive';
	messageSort := MessageSort::synchCall;
	argument += self.message.arguments -> map toArgument();
	var receiverClass : UML::Class = self.receiver.resolveone(UML::Lifeline).represents.type.oclAsType(UML::Class);
	receiverClass.ownedOperation += self.message -> map toOperation();	
}

mapping PlantUML::RequestMessage::toOperation(): UML::Operation {
	name := self.name;
	ownedParameter += self.arguments -> map toParameter();
}

mapping RequestMessageArgument::toParameter(): UML::Parameter {
	// Direction: IN is default
	// TODO: give name with integer
	name := if (self.name.oclIsUndefined())
		then 'inParam'
		else self.name
		endif;
}


mapping RequestMessageArgument::toArgument(): UML::LiteralInteger {
	value := 5;
}

mapping ReplyMessageDefinition::toUMLMessage(inout parentInteraction : UML::Interaction): UML::Message inherits
MessageDefinition::senderAndReceiver {
	name := self.message.name;
	sendEvent.name := name + '_' + 'send';
	receiveEvent.name := name + '_' + 'receive';
	messageSort := MessageSort::reply;
	var operation : UML::Operation := self.getOperation(result.name);
	if (not operation.oclIsUndefined()) {
		operation.ownedParameter += self.message.arguments -> map toParameter();
		if (not self.message.value.oclIsUndefined()) then {
			operation.ownedParameter += object UML::Parameter { 
				name := 'returnParam';
				direction := ParameterDirectionKind::_return;
			}
		} endif;
	}
}

query ReplyMessageDefinition::getOperation(name : String) {
	self.getClass().ownedOperation->any(op : UML::Operation | op.name = name);
}

query ReplyMessageDefinition::getClass(): UML::Class {
	return self.sender.resolveone(UML::Lifeline).represents.type.oclAsType(UML::Class);
}

mapping ReplyMessageArgument::toParameter(): UML::Parameter {

	// Direction: IN is default
	// TODO: give name with integer
	name := 'outParam';
	direction := ParameterDirectionKind::_out;
}

