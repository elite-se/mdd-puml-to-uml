modeltype UML uses "http://www.eclipse.org/uml2/5.0.0/UML";
modeltype PlantUML uses "http://www.mdd.elite/plantuml/PlantUML";

transformation PlantUMLToUMLTransformation(in source: PlantUML, out target: UML);

main() {
	object UML::Model {
		var diagrams = source.rootObjects()[Diagram];
		
		packagedElement += object UML::Package {
			name := 'Static';
			packagedElement += diagrams.elements[ParticipantDefinition].participant -> map toClass();
		};
		
		packagedElement += diagrams -> map toCollaboration();
			
		name := diagrams -> iterate( i: Diagram; newName : String = '' | newName + i.getName());
	};
}

query Diagram::getName(): String {
	if (self.elements[TitleDefinition]->isEmpty()) then {
		return 'Unnamed Model';
	} endif;
	return self.elements[TitleDefinition] -> iterate ( t: TitleDefinition; title : String = '' |
		title
		+ (if title = '' then '' else ' ' endif)
		+ t.getTitle()
	);
}

query TitleDefinition::getTitle(): String {
	return self.titleParts -> iterate ( tp: String; title: String = '' |
		title 
		+ (if title = '' then '' else ' ' endif)
		+ tp
	);
}

mapping Participant::toClass(): UML::Class {
	name := self.name.firstToUpper();
}

mapping Diagram::toCollaboration(): UML::Collaboration {
	name := self.getName();
	var interaction = object UML::Interaction {
		name := self.getName();
	};
	classifierBehavior := interaction;
	ownedBehavior := interaction;
	interaction.lifeline := self.elements[ParticipantDefinition].participant -> map toLifeline(interaction);
	interaction.message += self.elements[MessageDefinition] -> map toUMLMessage(interaction);
}

mapping ReplyMessageDefinition::test(out message : UML::Message, out sendOccurence : UML::MessageOccurrenceSpecification) {
	message.name := self.message.name;
	sendOccurence.message := message;
}

mapping Participant::toLifeline(parentInteraction: UML::Interaction): Lifeline {
	name := self.name;
	interaction := parentInteraction;
	var representedProperty := object UML::Property {
		name := self.name.toLower();
		type := self.resolveone(UML::Class);
	};
	represents := representedProperty;
	var parentCollaboration = parentInteraction.context.oclAsType(UML::Collaboration); 
	parentCollaboration.collaborationRole += representedProperty;
	parentCollaboration.ownedAttribute += representedProperty;
}

mapping MessageDefinition::toUMLMessage(inout parentInteraction : UML::Interaction) : UML::Message disjuncts 
RequestMessageDefinition::toUMLMessage,
ReplyMessageDefinition::toUMLMessage { }

mapping MessageDefinition::senderAndReceiver(inout parentInteraction : UML::Interaction): UML::Message {
	interaction := parentInteraction;
	var sendOccurence := object MessageOccurrenceSpecification {name := result.name + '_' + 'send'; 
		message := result;
		covered := self.sender.late resolveone(UML::Lifeline);
		enclosingInteraction := parentInteraction;
	};
	var receiveOccurence := object MessageOccurrenceSpecification {
		message := result;
		covered := self.receiver.late resolveone(UML::Lifeline);
		enclosingInteraction := parentInteraction;
	};
	sendEvent := sendOccurence;
	receiveEvent := receiveOccurence;
	parentInteraction.fragment += sendOccurence;
	parentInteraction.fragment += receiveOccurence;
}

mapping RequestMessageDefinition::toUMLMessage(inout parentInteraction : UML::Interaction): UML::Message inherits
MessageDefinition::senderAndReceiver {
	name := self.message.name;
	sendEvent.name := name + '_' + 'send';
	receiveEvent.name := name + '_' + 'receive';
	messageSort := MessageSort::synchCall;
}

mapping ReplyMessageDefinition::toUMLMessage(inout parentInteraction : UML::Interaction): UML::Message inherits
MessageDefinition::senderAndReceiver {
	name := self.message.name;
	sendEvent.name := name + '_' + 'send';
	receiveEvent.name := name + '_' + 'receive';
	messageSort := MessageSort::reply;
}

